
// Performance Cache Implementation
class PlayerProfileCache {
  constructor() {
    this.memoryCache = new Map();
    this.cacheExpiry = new Map();
    this.defaultTTL = 5 * 60 * 1000; // 5 minutes
  }
  
  set(key, value, ttl = this.defaultTTL) {
    this.memoryCache.set(key, value);
    this.cacheExpiry.set(key, Date.now() + ttl);
  }
  
  get(key) {
    const expiry = this.cacheExpiry.get(key);
    if (expiry && Date.now() > expiry) {
      this.memoryCache.delete(key);
      this.cacheExpiry.delete(key);
      return null;
    }
    return this.memoryCache.get(key) || null;
  }
  
  has(key) {
    return this.get(key) !== null;
  }
  
  clear() {
    this.memoryCache.clear();
    this.cacheExpiry.clear();
  }
}

// Global cache instance
const profileCache = new PlayerProfileCache();

// Cached fetch wrapper to eliminate redundant network calls
async function cachedFetch(url, options = {}, cacheKey = url) {
  // Check memory cache first (instant response)
  if (profileCache.has(cacheKey)) {
    const cached = profileCache.get(cacheKey);
    console.log(`üì¶ CACHE HIT: ${cacheKey} (0ms)`);
    return Promise.resolve(cached);
  }
  
  // Make network call only if not cached
  console.log(`üåê FETCH: ${cacheKey} (network call)`);
  const startTime = performance.now();
  
  try {
    const response = await cachedFetch(url, options, url);
    const data = await response.json();
    
    const duration = performance.now() - startTime;
    console.log(`‚úÖ FETCH COMPLETE: ${cacheKey} (${duration.toFixed(2)}ms)`);
    
    // Cache successful responses
    profileCache.set(cacheKey, { ok: response.ok, data, status: response.status });
    
    return { ok: response.ok, data, status: response.status };
  } catch (error) {
    const duration = performance.now() - startTime;
    console.log(`‚ùå FETCH FAILED: ${cacheKey} (${duration.toFixed(2)}ms)`);
    throw error;
  }
}

// Async localStorage wrapper to prevent blocking
class AsyncStorage {
  static async getItem(key) {
    return new Promise(resolve => {
      // Use setTimeout to make it async and non-blocking
      setTimeout(() => {
        try {
          const value = await AsyncStorage.getItem(key);
          resolve(value);
        } catch (error) {
          console.warn('localStorage getItem failed:', error);
          resolve(null);
        }
      }, 0);
    });
  }
  
  static async setItem(key, value) {
    return new Promise(resolve => {
      setTimeout(() => {
        try {
          await AsyncStorage.setItem(key, value);
          resolve(true);
        } catch (error) {
          console.warn('localStorage setItem failed:', error);
          resolve(false);
        }
      }, 0);
    });
  }
  
  static async removeItem(key) {
    return new Promise(resolve => {
      setTimeout(() => {
        try {
          localStorage.removeItem(key);
          resolve(true);
        } catch (error) {
          console.warn('localStorage removeItem failed:', error);
          resolve(false);
        }
      }, 0);
    });
  }
}

/**
 * PlayerProfile.js - Single Source of Truth for All Player Data
 * 
 * Comprehensive data hub that aggregates all backend player data:
 * - Core identity and wallet info
 * - Gaming statistics and achievements  
 * - Current tournament status
 * - Educational progress
 * - Payment history and status
 * - Leaderboard data and rankings
 * - Real-time data synchronization
 * - Event-driven updates
 * - Smart caching with invalidation
 * OPTIMIZED: Lazy initialization for better performance
 */

export class PlayerProfile {
    constructor() {
        // PERFORMANCE OPTIMIZATION: Lightweight constructor, no API calls
        this.profile = null;
        this.playerStatus = null;
        this.leaderboardData = null;
        this.paymentHistory = null;
        this.loading = false;
        this.error = null;
        this.apiBase = 'https://api.blockzonelab.com';
        
        // Lazy initialization state
        this.initialized = false;
        this.initPromise = null;
        
        // Event system for real-time updates
        this.eventListeners = {
            statusChanged: [],
            paymentUpdated: [],
            leaderboardUpdated: [],
            statsUpdated: [],
            profileUpdated: []
        };
        
        // Caching system
        this.cache = {
            profile: { data: null, timestamp: 0, ttl: 300000 }, // 5 minutes
            status: { data: null, timestamp: 0, ttl: 60000 },   // 1 minute
            leaderboard: { data: null, timestamp: 0, ttl: 120000 }, // 2 minutes
            payments: { data: null, timestamp: 0, ttl: 300000 } // 5 minutes
        };
        
        // Auto-refresh intervals
        this.refreshIntervals = {
            status: null,
            leaderboard: null
        };
        
        console.log('üèóÔ∏è PlayerProfile initialized as Single Source of Truth (lazy loading enabled)');
    }

    // PERFORMANCE OPTIMIZATION: Ensure initialization before any API calls
    async ensureInitialized() {
        if (this.initialized) return;
        if (this.initPromise) return this.initPromise;
        
        this.initPromise = this._initialize();
        return this.initPromise;
    }

    // PERFORMANCE OPTIMIZATION: Move all initialization logic here
    async _initialize() {
        try {
            console.log('üîÑ PlayerProfile: Starting lazy initialization...');
            
            // Check for existing player data and greet personally
            await this.checkForExistingPlayerAndGreet();
            
            this.initialized = true;
            console.log('‚úÖ PlayerProfile: Lazy initialization complete');
            
        } catch (error) {
            console.error('‚ùå PlayerProfile: Lazy initialization failed:', error);
            // Graceful fallback - profile still works with local data
            this.initialized = true;
        }
    }

    /**
     * Check for existing player data and greet personally
     */
    async checkForExistingPlayerAndGreet() {
        try {
            // First check local storage for immediate greeting
            const playerData = await AsyncStorage.getItem('blockzone_player');
            if (playerData) {
                const player = JSON.parse(playerData);
                const playerName = player.displayName || player.username || 'Player';
                const firstName = playerName.split('#')[0];
                console.log(`üë§ Welcome back, ${firstName}! Your profile is ready.`);
                
                // Now fetch fresh data from backend to update greeting if needed
                this.fetchBackendGreeting(player.id || player.playerId);
                return;
            }
            
            const quantumWallet = await AsyncStorage.getItem('quantum_wallet');
            const quantumUsername = await AsyncStorage.getItem('quantum_username');
            const quantumDisplayName = await AsyncStorage.getItem('quantum_display_name');
            
            if (quantumWallet && (quantumUsername || quantumDisplayName)) {
                const playerName = quantumDisplayName || quantumUsername;
                const firstName = playerName.split('_')[0] || playerName.split('#')[0];
                console.log(`üë§ Welcome back, ${firstName}! Your quantum profile is ready.`);
                
                // Fetch backend data for quantum players too
                this.fetchBackendGreeting(quantumWallet);
                return;
            }
            
            if (typeof window !== 'undefined' && window.identityManager) {
                setTimeout(() => {
                    const playerName = window.identityManager.getPlayerName?.();
                    const playerId = window.identityManager.getPlayerId?.();
                    if (playerName && !playerName.startsWith('Player#')) {
                        const firstName = playerName.split('#')[0];
                        console.log(`üë§ Welcome back, ${firstName}! Your identity is confirmed.`);
                        
                        // Fetch backend data for identity manager players
                        if (playerId) {
                            this.fetchBackendGreeting(playerId);
                        }
                    }
                }, 100);
            }
        } catch (error) {
            console.error('‚ùå Error checking for existing player:', error);
        }
    }
    
    async fetchBackendGreeting(playerId) {
        try {
            console.log('üîÑ Fetching fresh player data from backend for:', playerId);
            
            const response = await cachedFetch(`${this.apiBase}/api/players/status?player_id=${encodeURIComponent(playerId, , `${this.apiBase}/api/players/status?player_id=${encodeURIComponent(playerId)}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                }
            });
            
            if (response.ok) {
                const backendData = await response.json();
                
                if (backendData.player && backendData.player.displayName) {
                    const backendName = backendData.player.displayName;
                    const firstName = backendName.split('#')[0];
                    
                    console.log(`üåê Backend confirmed: Welcome back, ${firstName}! (Server: ${backendName})`);
                    
                    // Update local storage with fresh backend data
                    const localPlayer = JSON.parse(await AsyncStorage.getItem('blockzone_player') || '{}');
                    localPlayer.displayName = backendName;
                    localPlayer.username = firstName;
                    await AsyncStorage.setItem('blockzone_player', JSON.stringify(localPlayer));
                    
                    // Emit event for UI updates
                    this.emit('profileUpdated', { displayName: backendName, source: 'backend' });
                } else {
                    console.log('üåê Backend response received but no display name found');
                }
            } else {
                console.log('üåê Backend greeting fetch failed:', response.status, response.statusText);
            }
            
        } catch (error) {
            console.log('üåê Backend greeting fetch error (using local data):', error.message);
        }
    }

    /**
     * Get current player status (replaces direct GameWrapper API calls)
     */
    async getPlayerStatus(playerId = null, forceRefresh = false) {
        // PERFORMANCE OPTIMIZATION: Ensure initialization before API calls
        await this.ensureInitialized();
        
        const cacheKey = 'status';
        
        // Check cache first
        if (!forceRefresh && this.isCacheValid(cacheKey)) {
            console.log('üì¶ Returning cached player status');
            return this.cache[cacheKey].data;
        }

        // Get player ID from IdentityManager if not provided
        if (!playerId) {
            if (window.identityManager && window.identityManager.getPlayerId) {
                playerId = window.identityManager.getPlayerId();
            } else if (this.identityManager && this.identityManager.getPlayerId) {
                playerId = this.identityManager.getPlayerId();
            }
        }
        
        // Fallback to current player ID if still not available
        if (!playerId) {
            playerId = this.getCurrentPlayerId();
        }

        try {
            console.log('üîÑ Fetching fresh player status for:', playerId);
            const response = await cachedFetch(`${this.apiBase}/api/players/status?player_id=${encodeURIComponent(playerId, , `${this.apiBase}/api/players/status?player_id=${encodeURIComponent(playerId)}`);
            
            if (!response.ok) {
                throw new Error(`Status fetch failed: ${response.status}`);
            }
            
            const statusData = await response.json();
            
            // Update cache
            this.updateCache(cacheKey, statusData);
            this.playerStatus = statusData;
            
            // Emit status changed event
            this.emit('statusChanged', statusData);
            
            console.log('‚úÖ Player status updated:', statusData);
            return statusData;
            
        } catch (error) {
            console.error('‚ùå Failed to get player status:', error);
            throw error;
        }
    }

    /**
     * Get leaderboard data (replaces direct LeaderboardDisplay API calls)
     */
    async getLeaderboardData(forceRefresh = false) {
        // PERFORMANCE OPTIMIZATION: Ensure initialization before API calls
        await this.ensureInitialized();
        
        const cacheKey = 'leaderboard';
        
        // Check cache first
        if (!forceRefresh && this.isCacheValid(cacheKey)) {
            console.log('üì¶ Returning cached leaderboard data');
            return this.cache[cacheKey].data;
        }

        try {
            console.log('üîÑ Fetching fresh leaderboard data');
            const response = await cachedFetch(`${this.apiBase}/api/leaderboard`, , `${this.apiBase}/api/leaderboard`);
            
            if (!response.ok) {
                throw new Error(`Leaderboard fetch failed: ${response.status}`);
            }
            
            const leaderboardData = await response.json();
            
            // Update cache
            this.updateCache(cacheKey, leaderboardData);
            this.leaderboardData = leaderboardData;
            
            // Emit leaderboard updated event
            this.emit('leaderboardUpdated', leaderboardData);
            
            console.log('‚úÖ Leaderboard data updated:', leaderboardData);
            console.log('üîç Leaderboard scores structure:', leaderboardData.scores);
            if (leaderboardData.scores && leaderboardData.scores.length > 0) {
                console.log('üîç First score entry:', leaderboardData.scores[0]);
            }
            return leaderboardData;
            
        } catch (error) {
            console.error('‚ùå Failed to get leaderboard data:', error);
            throw error;
        }
    }

    /**
     * Update payment records (replaces direct PaywallManager API calls)
     */
    async updatePaymentRecord(playerId, paymentType, amount, transactionId) {
        try {
            console.log('üí∞ Updating payment record:', { playerId, paymentType, amount, transactionId });
            
            const response = await cachedFetch(`${this.apiBase}/api/players/payment`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    player_id: playerId,
                    payment_type: paymentType,
                    amount: amount,
                    transaction_id: transactionId,
                    timestamp: Date.now(, `${this.apiBase}/api/players/payment`)
                })
            });
            
            if (!response.ok) {
                throw new Error(`Payment update failed: ${response.status}`);
            }
            
            const result = await response.json();
            
            // Invalidate related caches
            this.invalidateCache(['status', 'profile', 'payments']);
            
            // Emit payment updated event
            this.emit('paymentUpdated', { paymentType, amount, transactionId, result });
            
            console.log('‚úÖ Payment record updated successfully');
            return result;
            
        } catch (error) {
            console.error('‚ùå Failed to update payment record:', error);
            throw error;
        }
    }

    /**
     * Grant unlimited pass (replaces direct PaywallManager API calls)
     */
    async grantUnlimitedPass(playerId) {
        try {
            console.log('üíé Granting unlimited pass for player:', playerId);
            
            const response = await cachedFetch(`${this.apiBase}/api/game/player/unlimited-pass`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    player_id: playerId,
                    pass_type: 'day_pass',
                    expires_at: new Date(Date.now(, `${this.apiBase}/api/game/player/unlimited-pass`) + 24 * 60 * 60 * 1000).toISOString()
                })
            });
            
            if (!response.ok) {
                throw new Error(`Unlimited pass grant failed: ${response.status}`);
            }
            
            const result = await response.json();
            
            // Invalidate related caches
            this.invalidateCache(['status', 'profile']);
            
            // Emit status changed event
            this.emit('statusChanged', { unlimited_pass_granted: true });
            
            console.log('‚úÖ Unlimited pass granted successfully');
            return result;
            
        } catch (error) {
            console.error('‚ùå Failed to grant unlimited pass:', error);
            // Don't throw - this is not critical for game flow
            return null;
        }
    }

    /**
     * Get comprehensive player data (aggregates all sources)
     */
    async getComprehensivePlayerData(playerId, forceRefresh = false) {
        try {
            console.log('üîÑ Loading comprehensive player data for:', playerId);
            
            // Load all data sources in parallel
            const [profile, status, leaderboard] = await Promise.allSettled([
                this.loadProfile(playerId),
                this.getPlayerStatus(playerId, forceRefresh),
                this.getLeaderboardData(forceRefresh)
            ]);
            
            const comprehensiveData = {
                profile: profile.status === 'fulfilled' ? this.profile : null,
                status: status.status === 'fulfilled' ? status.value : null,
                leaderboard: leaderboard.status === 'fulfilled' ? leaderboard.value : null,
                timestamp: Date.now()
            };
            
            console.log('‚úÖ Comprehensive player data loaded:', comprehensiveData);
            return comprehensiveData;
            
        } catch (error) {
            console.error('‚ùå Failed to load comprehensive player data:', error);
            throw error;
        }
    }

    /**
     * Force refresh all data
     */
    async refreshAllData(playerId) {
        console.log('üîÑ Force refreshing all player data');
        this.invalidateCache(['profile', 'status', 'leaderboard', 'payments']);
        return await this.getComprehensivePlayerData(playerId, true);
    }

    // ==========================================
    // EVENT SYSTEM
    // ==========================================

    /**
     * Add event listener
     */
    on(eventType, callback) {
        if (!this.eventListeners[eventType]) {
            this.eventListeners[eventType] = [];
        }
        this.eventListeners[eventType].push(callback);
        console.log(`üì° Event listener added for: ${eventType}`);
    }

    /**
     * Remove event listener
     */
    off(eventType, callback) {
        if (!this.eventListeners[eventType]) return;
        
        const index = this.eventListeners[eventType].indexOf(callback);
        if (index > -1) {
            this.eventListeners[eventType].splice(index, 1);
            console.log(`üì° Event listener removed for: ${eventType}`);
        }
    }

    /**
     * Emit event to all listeners
     */
    emit(eventType, data) {
        if (!this.eventListeners[eventType]) return;
        
        console.log(`üì° Emitting event: ${eventType}`, data);
        this.eventListeners[eventType].forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`‚ùå Error in event listener for ${eventType}:`, error);
            }
        });
    }

    // ==========================================
    // CACHING SYSTEM
    // ==========================================

    /**
     * Check if cache is valid
     */
    isCacheValid(cacheKey) {
        const cache = this.cache[cacheKey];
        if (!cache || !cache.data) return false;
        
        const age = Date.now() - cache.timestamp;
        return age < cache.ttl;
    }

    /**
     * Update cache with new data
     */
    updateCache(cacheKey, data) {
        this.cache[cacheKey] = {
            data: data,
            timestamp: Date.now(),
            ttl: this.cache[cacheKey].ttl
        };
        console.log(`üì¶ Cache updated for: ${cacheKey}`);
    }

    /**
     * Invalidate specific cache entries
     */
    invalidateCache(cacheKeys) {
        cacheKeys.forEach(key => {
            if (this.cache[key]) {
                this.cache[key].data = null;
                this.cache[key].timestamp = 0;
                console.log(`üóëÔ∏è Cache invalidated for: ${key}`);
            }
        });
    }

    /**
     * Clear all cache
     */
    clearCache() {
        Object.keys(this.cache).forEach(key => {
            this.cache[key].data = null;
            this.cache[key].timestamp = 0;
        });
        console.log('üóëÔ∏è All cache cleared');
    }

    // ==========================================
    // AUTO-REFRESH SYSTEM
    // ==========================================

    /**
     * Start auto-refresh for real-time updates
     */
    startAutoRefresh(playerId) {
        console.log('‚è∞ Starting auto-refresh for real-time updates');
        
        // Refresh player status every minute
        this.refreshIntervals.status = setInterval(async () => {
            try {
                await this.getPlayerStatus(playerId, true);
            } catch (error) {
                console.error('‚ùå Auto-refresh status failed:', error);
            }
        }, 60000); // 1 minute
        
        // Refresh leaderboard every 2 minutes
        this.refreshIntervals.leaderboard = setInterval(async () => {
            try {
                await this.getLeaderboardData(true);
            } catch (error) {
                console.error('‚ùå Auto-refresh leaderboard failed:', error);
            }
        }, 120000); // 2 minutes
    }

    /**
     * Stop auto-refresh
     */
    stopAutoRefresh() {
        console.log('‚è∞ Stopping auto-refresh');
        
        Object.values(this.refreshIntervals).forEach(interval => {
            if (interval) {
                clearInterval(interval);
            }
        });
        
        this.refreshIntervals = {
            status: null,
            leaderboard: null
        };
    }

    // ==========================================
    // UTILITY METHODS
    // ==========================================

    /**
     * Get current player ID from identity manager
     */
    getCurrentPlayerId() {
        // This will be updated when we integrate with IdentityManager
        if (window.identityManager && window.identityManager.getPlayerId) {
            return window.identityManager.getPlayerId();
        }
        return null;
    }

    /**
     * Initialize PlayerProfile with a player ID and start monitoring
     */
    async initialize(playerId) {
        console.log('üöÄ Initializing PlayerProfile for:', playerId);
        
        try {
            // Load comprehensive data
            await this.getComprehensivePlayerData(playerId);
            
            // Start auto-refresh
            this.startAutoRefresh(playerId);
            
            console.log('‚úÖ PlayerProfile initialized successfully');
            return true;
            
        } catch (error) {
            console.error('‚ùå PlayerProfile initialization failed:', error);
            throw error;
        }
    }

    /**
     * Cleanup when PlayerProfile is no longer needed
     */
    cleanup() {
        console.log('üßπ Cleaning up PlayerProfile');
        this.stopAutoRefresh();
        this.clearCache();
        this.eventListeners = {
            statusChanged: [],
            paymentUpdated: [],
            leaderboardUpdated: [],
            statsUpdated: [],
            profileUpdated: []
        };
    }

    async loadProfile(playerId) {
        this.loading = true;
        this.error = null;
        
        try {
            console.log('üë§ Loading profile for player:', playerId);
            const response = await cachedFetch(`${this.apiBase}/api/players/profile?player_id=${encodeURIComponent(playerId, , `${this.apiBase}/api/players/profile?player_id=${encodeURIComponent(playerId)}`);
            console.log('üë§ Profile response status:', response.status);
            
            if (response.ok) {
                const data = await response.json();
                console.log('üë§ Profile data received:', data);
                
                if (data.success) {
                    this.profile = data.profile;
                } else {
                    throw new Error(data.error || 'Failed to load profile');
                }
            } else if (response.status === 404) {
                // Profile doesn't exist yet - create a basic profile from available data
                console.log('üë§ Profile not found, creating basic profile');
                await this.createBasicProfile(playerId);
            } else {
                const errorText = await response.text();
                console.error('‚ùå Profile load failed:', response.status, errorText);
                throw new Error(`Failed to load profile (${response.status})`);
            }
        } catch (error) {
            console.error('‚ùå Profile load error:', error);
            this.error = error.message;
        } finally {
            this.loading = false;
        }
    }

    async createBasicProfile(playerId) {
        try {
            // Get player status to create a basic profile
            const statusResponse = await cachedFetch(`${this.apiBase}/api/players/status?player_id=${encodeURIComponent(playerId, , `${this.apiBase}/api/players/status?player_id=${encodeURIComponent(playerId)}`);
            if (statusResponse.ok) {
                const statusData = await statusResponse.json();
                
                // Create a basic profile from available data
                this.profile = {
                    player_id: playerId,
                    display_name: playerId, // Will be updated when they register
                    username: playerId,
                    email: null,
                    wallet_address: null,
                    account_type: 'wallet_first',
                    verification_status: 'unverified',
                    tier: 'anonymous',
                    account_status: 'active',
                    created_at: new Date().toISOString(),
                    last_activity: new Date().toISOString(),
                    
                    // Current Status
                    status: {
                        has_unlimited_pass: statusData.has_unlimited_pass || false,
                        has_used_free_game: statusData.has_used_free_game || false,
                        can_play_free: statusData.can_play_free !== undefined ? statusData.can_play_free : false,
                        requires_payment: statusData.requires_payment || false,
                        next_reset: statusData.next_reset,
                        current_day: statusData.current_day
                    },
                    
                    // Basic Gaming Statistics
                    gaming: {
                        lifetime_high_score: 0,
                        total_games_played: 0,
                        average_score: 0,
                        current_streak: 0,
                        tournament_wins: 0,
                        total_prizes_won: 0
                    },
                    
                    // Basic Rankings
                    rankings: {
                        current_tournament: 'N/A',
                        all_time: 'N/A',
                        weekly: 'N/A'
                    },
                    
                    // Basic Payment History
                    payments: {
                        total_spent: 0,
                        day_passes_purchased: 0,
                        individual_games_purchased: 0
                    },
                    
                    // Basic Education Progress
                    education: {
                        courses_completed: 0,
                        lessons_completed: 0,
                        certificates_earned: 0,
                        progress_percentage: 0
                    }
                };
                
                console.log('üë§ Basic profile created:', this.profile);
            } else {
                throw new Error('Unable to get player status');
            }
        } catch (error) {
            console.error('‚ùå Error creating basic profile:', error);
            throw new Error('Unable to create profile. Please try again later.');
        }
    }

    show() {
        if (this.loading) {
            this.showLoading();
            return;
        }

        if (this.error) {
            this.showError();
            return;
        }

        this.createProfileOverlay();
    }

    showLoading() {
        const overlay = document.createElement('div');
        overlay.className = 'profile-overlay';
        overlay.innerHTML = `
            <div class="profile-modal">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                    <p>Loading your profile...</p>
                </div>
            </div>
        `;
        document.body.appendChild(overlay);
    }

    showError() {
        const overlay = document.createElement('div');
        overlay.className = 'profile-overlay';
        overlay.innerHTML = `
            <div class="profile-modal">
                <div class="error-message">
                    <h3>‚ùå Profile Error</h3>
                    <p>${this.error}</p>
                    <button onclick="this.closest('.profile-overlay').remove()">Close</button>
                </div>
            </div>
        `;
        document.body.appendChild(overlay);
    }

    createProfileOverlay() {
        const overlay = document.createElement('div');
        overlay.className = 'profile-overlay';
        overlay.innerHTML = this.generateProfileHTML();
        document.body.appendChild(overlay);

        // Add event listeners
        overlay.querySelector('.close-btn').addEventListener('click', () => {
            overlay.remove();
        });

        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        });
    }

    generateProfileHTML() {
        const p = this.profile;
        
        return `
            <div class="profile-modal">
                <div class="profile-header">
                    <h2>${p.display_name}'s Profile</h2>
                    <button class="close-btn">‚úï</button>
                </div>
                
                <div class="profile-content">
                    <!-- Identity Section -->
                    <div class="profile-section">
                        <h3>üë§ Identity</h3>
                        <div class="identity-grid">
                            <!-- Primary Identity Info -->
                            <div class="identity-item primary-identity">
                                <label>üéÆ Username:</label>
                                <span class="username-display">${p.username || p.display_name || p.player_id}</span>
                            </div>
                            <div class="identity-item primary-identity">
                                <label>üíº Wallet Address:</label>
                                <span class="mono wallet-display">${p.wallet_address || 'Not Connected'}</span>
                                ${p.wallet_address ? '<span class="wallet-status connected">‚úÖ Connected</span>' : '<span class="wallet-status disconnected">‚ùå Not Connected</span>'}
                            </div>
                            
                            <!-- Secondary Identity Info -->
                            <div class="identity-item">
                                <label>üÜî Player ID:</label>
                                <span class="mono">${p.player_id}</span>
                            </div>
                            ${p.email ? `
                                <div class="identity-item">
                                    <label>üìß Email:</label>
                                    <span>${p.email}</span>
                                </div>
                            ` : ''}
                            <div class="identity-item">
                                <label>üìÖ Member Since:</label>
                                <span>${p.created_at ? new Date(p.created_at).toLocaleDateString() : 'Unknown'}</span>
                            </div>
                            <div class="identity-item">
                                <label>üèÜ Account Tier:</label>
                                <span class="tier-badge tier-${p.tier}">${p.tier}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Current Status -->
                    <div class="profile-section">
                        <h3>üéÆ Current Status</h3>
                        <div class="status-grid">
                            <div class="status-item ${p.status.has_unlimited_pass ? 'active' : ''}">
                                <span class="status-icon">${p.status.has_unlimited_pass ? '‚úÖ' : '‚ùå'}</span>
                                <span>Unlimited Pass</span>
                            </div>
                            <div class="status-item ${p.status.can_play_free ? 'active' : ''}">
                                <span class="status-icon">${p.status.can_play_free ? '‚úÖ' : '‚ùå'}</span>
                                <span>Free Game Available</span>
                            </div>
                            <div class="status-item">
                                <span class="status-icon">üïê</span>
                                <span>Next Reset: ${new Date(p.status.next_reset).toLocaleString()}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Gaming Stats -->
                    <div class="profile-section">
                        <h3>üèÜ Gaming Statistics</h3>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value">${(p.gaming.lifetime_high_score || 0).toLocaleString()}</div>
                                <div class="stat-label">Lifetime High Score</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${p.gaming.total_games_played || 0}</div>
                                <div class="stat-label">Games Played</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${(p.gaming.average_score || 0).toLocaleString()}</div>
                                <div class="stat-label">Average Score</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${p.gaming.current_streak || 0}</div>
                                <div class="stat-label">Current Streak</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${p.gaming.tournament_wins || 0}</div>
                                <div class="stat-label">Tournament Wins</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">$${(p.gaming.total_prizes_won || 0).toFixed(2)}</div>
                                <div class="stat-label">Total Prizes Won</div>
                            </div>
                        </div>
                    </div>

                    <!-- Rankings -->
                    <div class="profile-section">
                        <h3>üìä Rankings</h3>
                        <div class="rankings-grid">
                            <div class="ranking-item">
                                <span class="ranking-label">Current Tournament:</span>
                                <span class="ranking-value">${p.rankings.current_tournament || 'N/A'}</span>
                            </div>
                            <div class="ranking-item">
                                <span class="ranking-label">All-Time:</span>
                                <span class="ranking-value">${p.rankings.all_time || 'N/A'}</span>
                            </div>
                            <div class="ranking-item">
                                <span class="ranking-label">This Week:</span>
                                <span class="ranking-value">${p.rankings.weekly || 'N/A'}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Payment History -->
                    <div class="profile-section">
                        <h3>üí∞ Payment History</h3>
                        <div class="payment-grid">
                            <div class="payment-item">
                                <span class="payment-label">Total Spent:</span>
                                <span class="payment-value">$${(p.payments.total_spent || 0).toFixed(2)}</span>
                            </div>
                            <div class="payment-item">
                                <span class="payment-label">Day Passes:</span>
                                <span class="payment-value">${p.payments.day_passes_purchased || 0}</span>
                            </div>
                            <div class="payment-item">
                                <span class="payment-label">Individual Games:</span>
                                <span class="payment-value">${p.payments.individual_games_purchased || 0}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Education Progress -->
                    <div class="profile-section">
                        <h3>üìö Education Progress</h3>
                        <div class="education-grid">
                            <div class="education-item">
                                <span class="education-label">Courses Completed:</span>
                                <span class="education-value">${p.education.courses_completed || 0}</span>
                            </div>
                            <div class="education-item">
                                <span class="education-label">Lessons Completed:</span>
                                <span class="education-value">${p.education.lessons_completed || 0}</span>
                            </div>
                            <div class="education-item">
                                <span class="education-label">Certificates:</span>
                                <span class="education-value">${p.education.certificates_earned || 0}</span>
                            </div>
                            <div class="education-item">
                                <span class="education-label">Progress:</span>
                                <span class="education-value">${p.education.progress_percentage || 0}%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
}

// PlayerProfile class is now exported and initialized in index.html
// Enhanced as Single Source of Truth for all backend player data